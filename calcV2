.model small
.stack 100h
.data
    first_number db 7,0,7 dup('$') 
    second_number db 7,0,7 dup('$')
    
    first_num dw 0
    second_num dw 0 
    
    and_num dw 0
    or_num dw 0
    xor_num dw 0
    
    string db 'Enter number:',0dh,0ah,'$' 
    string_of db 'Overflow',0dh,0ah,'$'
    string_new db 'Please enter new',0dh,0ah,'$' 
    string_ne_cifra db 'V stroke sodersh ne cifra',0dh,0ah,'$'    
    string_n db 0dh,0ah,'$'

    string_and db 'AND=$'
    string_or db 'OR=$'
    string_xor db 'XOR=$' 
    string_not db 'NOT=$'
.code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;vvod
input proc
st_new:    
    mov ah,0ah    ;schitivaem stroku
    mov dx,bx     ;adres dx-kuda zapisivaem
    int 21h
    
    xor cx,cx
    mov cl,[bx+1] ;v cl nasha dlina
    
    push bx       ;bx - ukazivaet na nachalo nashego chisla
    add bx,2
    add bx,cx
    mov [bx],36   ;zapisivaem vmesto 0dh v poslednii simvol '$'
    pop bx
    
    call atoi     ;perevodim stroku v chislo
    cmp cx,3      ;esli 3 znachit v atoi bilo perepolnenie ili ne cifra
    je st_new
    ret
input endp 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;atoi
atoi proc
                  ;bx=16,dx-cifra,ax-result,
                  ;di - ukazivaet na nachalo stroki
    push bx
    mov di,bx
    add di,2
    
    xor ax,ax
    xor bx,bx
    xor cx,cx
    
    mov bx,10h
    
    cmp [di],'-'      ;soxranayem znak v cx i v konce sdelaen neg esli nado budet
    jne positive
    
otric:
    mov cx,1    ;1 - otricatel'noe
    push cx  
    inc di
    jmp my_neg_loop  

my_neg_loop:
    imul bx     ;ax=ax*10h
    
    jo pere     ;proverka na perepolnenie pri umnoshenii
    
    xor dx,dx   ;v dx pomeshaem cifru
    mov dl,[di]
    call cifra  ;proverka yavlaetsa simvol cifroi
                ;esli posle etogo cx=1 to znacit v stroke bila ne cifra
    cmp cx,1
    je ne_cifra_end
    cmp cx,2
    je letter_neg
    sub dl,'0'
    sub ax,dx
    jo pere     ;proverka na perepolnenie pri add
    jmp go_next_neg
letter_neg:
    sub dl,55
    sub ax,dx
    jo pere     ;proverka na perepolnenie pri add
go_next_neg:    
    inc di
    cmp [di],'$';proverka na konec stroku
    je gotovo
jmp my_neg_loop
      
positive:
    mov cx,0    ;positiv
    push cx
    jmp my_loop
        
my_loop:
    imul bx     ;ax=ax*10h 
    
    jo pere     ;proverka na perepolnenie pri umnoshenii
    
    xor dx,dx   ;v dx pomeshaem cifru
    mov dl,[di]
    call cifra  ;proverka yavlaetsa simvol cifroi
                ;esli posle etogo cx=1 to znacit v stroke bila ne cifra
    cmp cx,1
    je ne_cifra_end
    cmp cx,2
    je letter
    sub dl,'0'
    add ax,dx
    jo pere;proverka na perepolnenie pri add
    jmp go_next
letter:
    sub dl,55
    add ax,dx
    jo pere;proverka na perepolnenie pri add
go_next:    
    inc di
    cmp [di],'$';proverka na konec stroku
    je gotovo
jmp my_loop
;;
ne_cifra_end:
    pop cx
    mov cx,3   
    pop bx
    output string_n
    output string_ne_cifra
    ret
pere: 
    pop cx
    mov cx,3
    pop bx
    output string_n
    output string_of 
    output string_new
    ret   
gotovo:
    pop cx
    cmp cx,1
    jne return
    neg ax; ax=-ax   
return:
    pop bx
    ret   
atoi endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cifra check
cifra proc
                
    cmp dl,30h  
    jb ne_cifra 
    cmp dl,39h  
    ja ne_cifra
    mov cx,0
    ret
ne_cifra:
	cmp dl,41h  
    jb ne_cifra_
    cmp dl,46h  
    ja ne_cifra_
	mov cx,2
    ret
ne_cifra_:
    mov cx,1        
    ret                                   
cifra endp 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;to string
to_string proc ;v ax nashe chislo
    xor cx,cx
    mov bx,10h
    test ah,80h
    js out_minus
    jmp again
out_minus: 
    push ax
    mov ah,02h
    mov dl,'-'
    int 21h
    pop ax
    neg ax
again:
    sub dx,dx
    div bx
    inc cx
    push dx
    cmp ax,0
    jne again
loop_output:
    pop dx
    add dx,30h
    cmp dx,39h
    jle no_more_9
    add dx,7
no_more_9:
    mov ah,2
    int 21h
    loop loop_output:
      
    ret
to_string endp  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;and
and_proc proc
    xor ax,ax
    xor bx,bx
    
    mov ax,first_num
    mov bx,second_num
    
    and ax,bx
    
    mov and_num,ax
       
    ret
and_proc endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;or
or_proc proc
    xor ax,ax
    xor bx,bx
    
    mov ax,first_num
    mov bx,second_num
    
    or ax,bx
    
    mov or_num,ax
        
    ret
or_proc endp 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;xor
xor_proc proc
    xor ax,ax
    xor bx,bx
    
    mov ax,first_num
    mov bx,second_num
    
    xor ax,bx
    
    mov xor_num,ax
    
    ret
xor_proc endp    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not
not_proc proc    
    not ax    
    ret
not_proc endp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;output
output macro str
    mov ah,9 
    mov dx,offset str
    int 21h
    xor ax,ax
endm   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;start
start:
    mov ax,@data
    mov ds,ax    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
    output string    
    lea bx,first_number
    call input
    mov first_num,ax        
    output string_n    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    output string        
    lea bx,second_number
    call input
    mov second_num,ax
    output string_n      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
call and_proc
    mov ax,and_num
    push ax
    output string_and
    pop ax
    push ax
    call to_string
    pop ax
    output string_n 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
call or_proc
    mov ax,or_num
    push ax
    output string_or
    pop ax  
    push ax
    call to_string 
    pop ax
    output string_n 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
call xor_proc 
    mov ax,xor_num
    push ax
    output string_xor
    pop ax       
    push ax
    call to_string
    pop ax
    output string_n
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    output string_not
    mov ax,first_num
    call not_proc
    push ax
    call to_string
    pop ax
    output string_n  
    
    output string_not
    mov ax,second_num  
    call not_proc
    push ax
    call to_string
    pop ax
    output string_n 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
to_end:    
    mov ah,4ch
    int 21h   
end start
